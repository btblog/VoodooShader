/*
 * This file is part of the Voodoo Shader Framework.
 *
 * Copyright (c) 2010-2012 by Sean Sube
 *
 * The Voodoo Shader Framework is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser
 * General Public License as published by the Free Software Foundation; either version 3 of the License, or (at your option)
 * any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along with this program; if not, write to
 * the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 US
 *
 * Support and more information may be found at
 *   http://www.voodooshader.com
 * or by contacting the lead developer at
 *   peachykeen@voodooshader.com
 */

#pragma once

namespace VoodooShader
{
     /**
      * @page voodoo_spec_module Voodoo Shader Module Specifications
      *
      * The Voodoo Shader core library is designed to provide a generic framework and certain Voodoo-specific features to 
      * help support shaders. To allow additional features without breaking compatibility with other compilers or systems, 
      * Voodoo Shader provides a class-based plugin interface. Modules may be added and classes provided by those modules 
      * created and used within Voodoo or adapters. To handle loading these modules, a known interface is required with a 
      * few specific features.
      *
      * @section voodoo_spec_module_exports Module Exports
      *
      * Each Voodoo Shader module must export a set of 4 functions. These are used by the core to load and query the 
      * module's version and what classes it provides. All these functions must be exported by name only, with no mangling 
      * or decoration of any kind.
      *
      * @subsection voodoo_spec_module_exports_version ModuleVersion
      *
      * @code const Version * ModuleVersion(); @endcode
      *
      * The ModuleVersion function returns a constant Version struct with the module's name, version and various flags. This
      * is used primarily for logging purposes, but can provide basic version-validation.
      *
      * @subsection voodoo_spec_module_exports_count ClassCount
      *
      * @code const uint32_t ClassCount(); @endcode
      *
      * Returns the total number of classes that may be created by this module.
      *
      * @note Any class provided by this module that may be created externally must be listed by this function.
      *
      * @subsection voodoo_spec_module_exports_info ClassInfo
      *
      * @code const wchar_t * ClassInfo(const uint32_t index, Uuid refid); @endcode
      *
      * Returns the name and CLSID of the given class. This is used to register the classes in the core ModuleManager when
      * the module is loaded. The return value is a pointer to the class name or nullptr if the index is invalid, and the
      * clsid parameter is filled with the CLSID or unchanged if the index is invalid.
      *
      * @note Any class provided by this module that may be created externally must be listed by this function and
      *     and ClassInfo, using the same index.
      *
      * @subsection voodoo_spec_module_exports_create ClassCreate
      *
      * @code IObject * ClassCreate(const uint32_t index, ICore * pCore); @endcode
      *
      * Creates a new instance of the given class, bound to the provided Core. For classes needing additional data, they can
      * cache and/or use the core.
      *
      * @note Class constructors @em may throw exceptions, but these must be caught within the create function and must not
      *     propagate between modules (this can cause crashes). If an error occurs, nullptr must be returned.
      *
      * @note Any class provided by this module that may be created externally must be listed by this function and
      *     and ClassInfo, using the same index.
      *
      * @section voodoo_spec_iobject IObject Interface
      *
      * Every class used in Voodoo Shader @em must derive from the IObject interface. The methods provided are vital for 
      * object lifetime management and garbage collection. This is performed in a manner very much like COM, with each 
      * object managing reference count internally.
      *
      * Every object, except one which implements ICore, must hold a non-incremented reference to its parent. This allows
      * tracking up without causing circular references. The object may both temporarily increment the reference, when it
      * needs a short-term guarantee of validity, or pass the reference (where it may be incremented).
      *
      * @subsection voodoo_spec_iobject_addref IObject::AddRef
      * @code uint32_t IObject::AddRef() CONST @endcode
      *
      * Increments the internal reference count by 1 and returns the new count, no other effects shall be caused.
      *
      * @subsection voodoo_spec_iobject_release IObject::Release
      * @code uint32_t IObject::Release() CONST @endcode
      *
      * Decrements the internal reference count by 1 and returns the new count. If the new count is 0, the object must be
      * deleted (<tt>delete this;</tt>), no other effects shall be caused. This guarantees correct memory allocation and
      * deallocation, safe from compiler or module boundaries.
      *
      * @note As AddRef and Release require no other effects, it may be necessary to provide initialization and/or reset
      *     functions. This additionally helps provide safer setup/teardown, outside of process startup and termination.
      *
      * @subsection voodoo_spec_iobject_query IObject::QueryInterface
      * @code VoodooResult IObject::QueryInterface(Uuid refid, IObject ** ppOut) CONST @endcode
      *
      * Queries the object for a particular interface.
      *
      * If @a refid is a not-null IID and the object implements the interface passed in @a refid or if @a refid is the 
      * object's ClsId, it must place a pointer providing that interface into @a ppOut and return @a VSF_OK. The pointer 
      * must evaluate equal to any other pointer to the same object, regardless of interface. The object's reference count 
      * must be incremented, from the pointer to be returned.
      *
      * If @a ppOut is a nullptr, the call must fail with invalid parameters.
      *
      * If the object does not implement the class or interface in @a refid, the call must fail with invalid Uuid.
      *
      * All IObject-derived classes must provide interfaces for IObject, their parent interface(s), and their class. Calls
      * to QueryInterface must be symmetric (if <tt>QI(A)->B</tt> succeeds, then <tt>QI(QI(A)->B)->A</tt> must as well),
      * transitive (if <tt>QI(QI(A)->B)->C</tt> succeeds, then <tt>QI(A)->C</tt> must as well), and reflexive
      * (<tt>QI(A)->A</tt> must always succeed).
      *
      * This is not to say that all objects of type <tt>A</tt> must behave the same; these guarantees must hold for any
      * single object throughout its lifetime. Two objects of type <tt>A</tt> may be unable to provide an interface
      * based on internal conditions (for example, if <tt>A1</tt> is an IObject queried from an ICore and <tt>A2</tt> is an
      * IObject queried from an IParser, <tt>A2</tt> will not be able to provide an interface to ICore, but must be able to
      * do so for IParser).
      *
      * For VSCore (which implements ICore and IObject) an example QueryInterface may be:
      *
      * @code
      * if (!ppOut)
      * {
      *     return VSFERR_INVALIDPARAMS;
      * } 
      * else 
      * {
      *     if (clsid == IID_IObject)
      *     {
      *         *ppOut = static_cast<const IObject*>(this);
      *     }
      *     else if (clsid == IID_ICore)
      *     {
      *         *ppOut = static_cast<const ICore*>(this);
      *     }
      *     else if (clsid == CLSID_VSCore)
      *     {
      *         *ppOut = static_cast<const VSCore*>(this);
      *     }
      *     else
      *     {
      *         *ppOut = nullptr;
      *         return vSFERR_INVALIDUUID;
      *     }
      *     (*ppOut)->AddRef();
      *     return VSF_OK;
      * }
      * @endcode
      *
      * @subsection voodoo_spec_iobject_tostring IObject::ToString
      * @code String IObject::ToString() CONST @endcode
      *
      * Returns a formatted string made up of the object's type <em>name</em> (which may be the object's ClsId, although
      * this is not recommended) and optionally some data. This string must follow the form:
      *
      * @code
      * ImplName()
      * ImplName(Data, Data)
      * @endcode
      *
      * If no data is provided, the data section inside the parentheses must be empty but the parentheses must be present.
      * If data is provided, it must be in a <tt>(key: value[, ...])</tt> form with all colons, commas, and paranthese 
      * escaped.
      *
      * @subsection voodoo_spec_iobject_getcore IObject::GetCore
      * @code ICore * IObject::GetCore() CONST @endcode
      *
      * Returns a reference to the object's parent core.
      *
      * @subsection voodoo_spec_module_throw throw()
      * <b>Methods and functions in any class or interface derived from IObject shall not throw exceptions or allow them to
      * propogate out from the function.</b> If error reporting is necessary, an error value should be returned and the
      * exception logged. This is a necessary safety precaution, as modules may be created with different compilers or
      * languages and it may not be possible to safely pass exceptions.
      *
      * Methods which call other functions that may throw (such as standard library functions) must catch and handle any
      * potential exception and prevent it from propagating. Constructors may throw, and all calls to <tt>new</tt> should be
      * wrapped in try/catch blocks to handle both exceptions from the ctor and various other exceptions (such as memory).
      *
      * @section voodoo_spec_module_docs Documentation
      *
      * If possible, module creators should provide full documentation for modules, including class names and interfaces
      * implemented from each.
      *
      * The Voodoo Shader project offers hosting for this documentation on the Github project site. Modules may request a 
      * wiki page and space for doxygen-generated documents, which will be fully linked into the main project. Modules not 
      * wishing to be on the main project may instead request a link to other documentation.
      *
      * @page voodoo_spec_adapter Adapter Specifications
      *
      * The adapter serves as a binding between an unknown (by the core library) graphics API and the Voodoo Shader 
      * Framework. The adapter is responsible for handling any interaction between the two, performing translation as 
      * necessary, and generally polishing the details. In many senses, adapters are regular classes provided by modules and
      * they must follow the @ref voodoo_spec_module as any other module. However, adapter classes must fit a very specific 
      * set of behavior rules and perform exactly as expected by the core, and only one adapter object is created at a time.
      *
      * Adapter modules are free to provide other classes, in support of or unrelated to, the adapter itself. The adapter
      * must provide at least one implementation each of IAdapter and ITexture.
      *
      * It is recommended that the adapter name be of the form <tt>[Name]Adapter</tt> and each supporting class use
      * <tt>[Name]classname</tt>, to easily identify them. If the adapter or module is part of the framework, the name
      * scheme extends to the module's name (<tt>Voodoo/[Name]</tt>) and filename (<tt>Voodoo_[Name].dll</tt>). Each
      * framework adapter is given a short one word name related to its game in some manner.
      *
      * For further details on the behavior required of adapters, please refer to the IAdapter interface documentation.
      *
      * @section voodoo_spec_adapter_context Adapter Context
      *
      * Due to varying needs between adapters regarding the management, and destruction, of hardware render contexts, the 
      * core will query the adapter for the context or device when necessary and only hold a reference for the duration of 
      * the call needing the context. The type of context to be retrieved depends on the core's default compile flags, or 
      * explicit flags if given in the call.
      * @since 0.5.6
      *
      * @warning Adapters must not create any shaders or parameters if they cannot provide the core with a valid context.
      *     Errors will be returned if this is attempted. To fully support Voodoo Shader features, adapters should not 
      *     directly use the context where the core provides methods to handle a particular feature.
      *
      * @section voodoo_spec_adapter_caps Capabilities
      *
      * Voodoo Shader provides a mechanism for shaders to verify the hardware has certain capabilities, for the shader in 
      * general or a particular technique. If the hardware does not meet these caps, as reported by the adapter, the shader 
      * will fail to load or the technique fail to validate. Adapters must provide accurate values for all given caps, and 
      * may provide more.
      *
      * Capabilities are validated as a minimum and true is considered greater than false, thus a target requirement of 4 
      * will succeed with 4 or more, and a flow control requirement of false will succeed on true or false.
      *
      * Most instruction and type errors, including instruction count, will cause the shader or technique to fail during 
      * compilation or validation. These caps are primarily for requirements not fatal in the compiler.
      *
      * @subsection voodoo_graphics_shaders_caps_textures CapsTextures
      * Reports the maximum number of textures which may be bound at a time. 
      * @par Type
      *     uint/UT_UInt32
      * @par Value
      *     Typically 8, may be lower for especially old hardware.
      *
      * @subsection voodoo_graphics_shaders_caps_targets CapsTargets
      * Reports the maximum number of render targets which may be bound at a time. 
      * @par Type
      *     uint/UT_UInt32
      * @par Value
      *     Typically 4, may be lower for old hardware.
      *
      * @subsection voodoo_graphics_shaders_caps_lights CapsLights
      * Reports the maximum number of hardware lights available. 
      * @par Type
      *     uint/UT_UInt32
      * @par Value
      *     Typically 8, may be lower for especially old hardware.
      *
      * @subsection voodoo_graphics_shaders_caps_instructions CapsInstructions
      * Reports the maximum number of instructions that may be run in a single program. The first pair are vertex, the
      * second pixel; the first value of each pair is arithmetic instructions, the second is texture. If vertex textures
      * are not available, the second value will be 0, otherwise it will represent.
      * @par Type
      *     uint4/UT_UInt32[4]
      * @par Value
      *     The first pair will typically be 65536/0 for VS2.0 and earlier, 65536/4 for VS3.0 or better. The second pair
      *     will typically be 8/4 for PS1.0-1.3, 6/8 per phase for PS1.4, 32/64 for PS2.0, 512/512 for PS2.0x, 
      *     65536/65536 for 3.0, and unlimited for 4.0 and better.
      *
      * @subsection voodoo_graphics_shaders_caps_registers CapsRegisterCount
      * Reports how many registers are available, and what varieties. The first pair of values are vertex, the second are
      * pixel; the first value in each pair is temporary registers, the second is static.
      * @par Type
      *     uint4/UT_UInt32[4]
      * @par Value
      *     Typically 12/96/2/8 for SM1.1-1.4, 12/256/12/32 for SM2.0, 32/256/32/224 for SM3.0, and 
      *     4096/16x4096/4096/16x4096 for SM4.0 and better.
      *
      * @subsection voodoo_graphics_shaders_caps_flowcontrol CapsFlowControl
      * Reports whether flow control is available, and what varieties. The first pair of values are vertex, the second are
      * pixel; the first value in each pair is static flow control, second is dynamic.
      * @par Type
      *     bool4/UT_Bool[4]
      * @par Value
      *     Typically no/no in both pairs for SM1.0-1.4, yes/no for SM2.0, and yes/yes for SM3.0 and better.
      *
      * @page voodoo_quality Quality (Code and Testing)
      *
      * The Voodoo Shader Framework is designed to work across many games, created across a wide variety of compilers,
      * with numerous graphics libraries, code styles and time periods. To maximize stability and speed, both critical to
      * Voodoo's purpose, all framework projects must meet extremely strict code quality and testing requirements. These are
      * designed to eradicate bugs within Voodoo Shader itself and provide the best user and developer experience possible,
      * especially considering the high degree of complexity and wide scope of the project.
      *
      * Third-party code that is used in Voodoo Shader, or adapters that are not part of the official project, do not need 
      * to use these rules, but they can rely on Voodoo Shader to follow them. Any bugs, potential bugs, performance 
      * bottlenecks, possible points of improvement or generally questionable code encountered in Voodoo should be reported 
      * as soon as possible. Please file an issue with as much information as possible in the Voodoo Shader bug tracker.
      *
      * @section voodoo_quality_code Code Quality
      *
      * To maintain high code quality within Voodoo Shader, a number of systems are used.
      *
      * The simplest, and often most important, is proper use of compiler messages. The framework is compiled with level 4
      * warnings enabled (the strictest standard level, significantly higher than the default) and warnings-as-errors
      * enabled. These measures guarantee the code has no defects the compiler can locate and conforms to all best-practices
      * the compiler is aware of.
      *
      * The second measure, used to discover more complex issues, is full PREfast analysis. All Voodoo framework code is
      * fully annotated with SAL and is submitted to the static analyzer during compilation. Again, any warnings are treated
      * as fatal errors and all rules are enabled. PREfast is capable of catching a number of common errors and using SAL to
      * locate differences between expected and actual behavior.
      *
      * In addition to analysis with PREfast, Voodoo framework code is also run through CppCheck for general errors and
      * KWStyle for style evaluation.
      *
      * All Voodoo framework code has passed both the compiler and PREfast's analysis before release and builds with no
      * warnings from either.
      *
      * @section voodoo_quality_testing Testing
      *
      * To verify the results of the code quality requirements, all Voodoo framework code is run through an extensive set of
      * unit tests and test scenarios and detailed metrics collected. These methods are heavily inspired by the SQLite
      * project and their excellent testing.
      *
      * Unit tests are used to check specific behaviors or code segments, often a single function or object. These use a
      * number of methods to make sure the code behaves as expected, especially providing known-incorrect parameters or data
      * and verifying the error is caught.
      *
      * A more involved test harness is used to run full-scenario tests, where the framework is actually used to apply an
      * effect to a real graphics context, and the results tested. These provide a larger picture, making sure all
      * components work together well.
      *
      * Before running tests, all code is instrumented to provide various pieces of information. The most useful of these is
      * code coverage: what source code has been used in the tests. This is typically measured in two ways: statement
      * coverage and branch coverage. Statement coverage tests that each statement has been run, but does not test all
      * possible outcomes. This means each line of code has probably been run, but offers no guarantees as to actual code
      * used. Branch coverage tests every possible branch of every statement, providing much more complete coverage. Voodoo
      * strives for 100% branch coverage from unit tests and additional coverage of relevant code from scenario tests. This
      * means, simply, that all code is tested in theory and in use before actual in-game testing begins.
      *
      * @section voodoo_quality_docs Documentation
      *
      * The final quality requirement is comprehensive documentation. Voodoo provides a significant amount of documentation,
      * covering everything from technical details of interfaces to expected behavior to graphics theory to quality
      * requirements. This documentation is generated with the doxygen tool and provided in a number of formats, notably on
      * the web at the Github project pages.
      *
      * To make sure documentation is sufficiently complete, the framework should produce no errors or warnings from code
      * during doxygen generation. This performs basic checks, such as requiring every object and function be documented
      * with details for each parameter.
      *
      * The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
      * and "OPTIONAL" in the documentation are to be interpreted as described in RFC 2119.
      */
}
